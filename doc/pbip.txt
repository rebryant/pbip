The PBIP Pseudo-Boolean Proof Format
Randal E. Bryant
23 February 2023

The PBIP (Pseudo-Boolean Implication Proof) format describes a
sequence of transformations on a set of pseudo-Boolean (PB)
constraints leading to an infeasible constraint.  The file therefore
describes an unsatisfiability proof for a PB constraint problem.

Two reasoning modes are supported:

* Implication mode, where each new constraint follows by implication
  from one or two previous constraints.

* Reverse unit propagation (RUP) mode, where the validity of a
  constraint by contradiction.  That is, a series of unit propagations
  are performed based on the complement of the constraint and other
  constraints until a contradiction is reached.

The format assumes that each input constraint is encoded as a set of
clauses in conjunctive normal form (CNF).  The clauses for all of the
constraints are provided as a file in the standard DIMACS format.

When in implication mode, each derived constraint must follow by
implication from either one or two preceding constraints, referred to
as the "antecedents".  That is, consider PB constraints P_1, P_2, and
P.  Each of these encodes a Boolean function.  For P to follow from
P_1, the constraints must satisfy P_1 ==> P.  For P to follow from P_1
and P_2, the constraints must satisfy P_1 & P_2 ==> P.  An antecedent
constraint can be any of the following: an input constraint, one
proved by an implication step, or the target constraint of a completed
counterfactual reasoning sequence.

When in RUP mode, the constraint to be derived is set as a target, and
a (initially empty) set of unit constraints is accumulated.  Each RUP
step then derives one of more additional unit constraints based on the
set of previously derived unit constraints, as well as either the
complement of the target constraint or some other preceding
constraint.  The final step should then cause a contradiction---the
set of accumulated unit literals falsifies the final constraint.

PBIP files build on the OPB format for describing PB constraint
problems, as documented in:

   https://www.cril.univ-artois.fr/PB12/format.pdf

We allow an extension to the OPB format for writing a PB formula: a
variable name of the form xN can be preceded by '~' (e.g., ~x2) to
indicate its logical negation.  This extension is also allowed by many
other tools.

There are four types of lines:

1. Comment lines begin with '*' and contain arbitrary text

2. Input lines begin with 'i'.  This is followed by a constraint,
   expressed in OPB format and terminated by ';' Then a set of clause
   numbers is listed, separated by spaces and terminated with
   end-of-line.  Forming the conjunction of these clauses and
   existentially quantifying any variables that are not listed in the
   PB formula should yield a Boolean function implying that of the PB
   constraint.

3. Implication-mode assertion lines begin with 'a'.  This is followed
   by a constraint, expressed in OPB format and terminated by ';' Then
   either one or two constraint IDs is listed, separated by spaces and
   terminated with end-of-line.  Constraints are numbered from 1,
   starting with the input constraints.

4. RUP lines begin with 'u'.  This is followed by a constraint,
   expressed in OPB format and terminated by ';' Then a sequence of
   lists is given, where each list is of the form [C L1 ... Lk]
   indicating that constraint C will propagate additional units L1,
   ..., Lk.  C can either be the ID of a previous constraint, or it
   can be that of the current constraint.  The latter case is known as
   a "self reference", and its unit propagations should be based on
   the negation of the target constraint.  The final list is qof the
   form [C], and it must be falsified by the accumulated set of
   literals.
 
For an unsatisfiability proof, the final constraint should be
infeasible, e.g., 0 >= 1.

EXAMPLE 1

The following is an example for the Pigeonhole problem, with four
pigeons and three holes.  There are 12 variables, representing all
possible placements of a pigeon in a hole.  For each pigeon, there is
an at-least-one (ALO) constraint stating that it must be in some hole.
For each hole, there is an at-most-one (AMO) constraint stating that
it can contain at most one pigeon.

CNF Input:

p cnf 12 22
c Pigeon 1 ALO
1 5 9 0
c Pigeon 2 ALO
2 6 10 0
c Pigeon 3 ALO
3 7 11 0
c Pigeon 4 ALO
4 8 12 0
c Hole 1 AMO
-1 -2 0
-1 -3 0
-1 -4 0
-2 -3 0
-2 -4 0
-3 -4 0
c Hole 2 AMO
-5 -6 0
-5 -7 0
-5 -8 0
-6 -7 0
-6 -8 0
-7 -8 0
c Hole 3 AMO
-9 -10 0
-9 -11 0
-9 -12 0
-10 -11 0
-10 -12 0
-11 -12 0


PBIP File:

* Input CNF file pigeon-direct-3.cnf uses direct encoding
* Pigeon 1 ALO
i +1  x1 +1  x5 +1  x9 >=  1 ; 1
* Pigeon 2 ALO
i +1  x2 +1  x6 +1 x10 >=  1 ; 2
* Pigeon 3 ALO
i +1  x3 +1  x7 +1 x11 >=  1 ; 3
* Pigeon 4 ALO
i +1  x4 +1  x8 +1 x12 >=  1 ; 4
* Hole 1 AMO
i -1  x1 -1  x2 -1  x3 -1  x4 >= -1 ;  5  6  7  8  9 10
* Hole 2 AMO
i -1  x5 -1  x6 -1  x7 -1  x8 >= -1 ; 11 12 13 14 15 16
* Hole 3 AMO
i -1  x9 -1 x10 -1 x11 -1 x12 >= -1 ; 17 18 19 20 21 22
* Add pigeon constraints
a +1  x1 +1  x2 +1  x5 +1  x6 +1  x9 +1 x10 >=  2 ; 1 2
a +1  x3 +1  x4 +1  x7 +1  x8 +1 x11 +1 x12 >=  2 ; 3 4
a +1  x1 +1  x2 +1  x3 +1  x4 +1  x5 +1  x6 +1  x7 +1  x8 +1  x9 +1 x10 +1 x11 +1 x12 >=  4 ; 8 9
* Add hole constraints
a -1  x1 -1  x2 -1  x3 -1  x4 -1  x5 -1  x6 -1  x7 -1  x8 >= -2 ; 5 6
a -1  x1 -1  x2 -1  x3 -1  x4 -1  x5 -1  x6 -1  x7 -1  x8 -1  x9 -1 x10 -1 x11 -1 x12 >= -3 ; 7 11
* Sum pigeon & hole constraints
a >= 1 ; 10 12

EXAMPLE #2

RUP Proof Example

The following example has five input constraints.  It uses RUP over
the first four to justify the constraint 2 * ~x1 + 1 * ~x2 + 1 * ~x3
>= 2.  Logically, this is equivalent to ~x1 | (~x2 & ~x3).  The fact
that a single PB constraint can represent a Boolean expression of this
complexity demonstrates the expressive power of PB constraints.  The
final input constraint is the negation of the target constraint: 2 *
x1 + 1 * x2 + 1 * x3 >= 3, encoding the Boolean formula x1 & (x2 |
x3).  Combining the target constraint with the final will therefore
yield a contradiction.


CNF file:

p cnf 5 6
c Input constraint #1
-2  4 0
c Input constraint #2
-1 -4 0
c Input constraint #3
-3  5 0
c Input constraint #4
-3  -5 0
c Final input constraint
1 0
2 3 0

PBIP file:

* Input constraint #1
i       1 ~x2       1  x4            >= 1 ; 1
* Input constraint #2
i 1 ~x1             1 ~x4            >= 1 ; 2
* Input constraint #3
i             1 ~x3       1  x5      >= 1 ; 3
* Input constraint #4
i             1 ~x3       1 ~x5      >= 1 ; 4
* RUP step justifies constraint #5.  Note the two self references.
u 2 ~x1 1 ~x2 1 ~x3 >= 2 ;  [5 1]  [2 -4]  [1 -2]  [5 3]  [3 5]  [4]
* Final input constraint: Contradict our proposed target constraint.
* This becomes constraint #6
i 2  x1 1  x2 1  x3 >= 3 ; 5 6
* Target constraint contradicts input constraint #5
a >= 1 ; 5 6


